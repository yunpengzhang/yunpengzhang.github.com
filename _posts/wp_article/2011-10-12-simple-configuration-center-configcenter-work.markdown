---
author: illidan
comments: true
date: 2011-10-12 01:42:09+00:00
layout: post
slug: simple-configuration-center-configcenter-work
title: '简单配置中心（ConfigCenter）的工作方式 '
wordpress_id: 159
categories:
- 开发运营
tags:
- 配置中心
---

ConfigCenter（CC）管理一个/多个系统拥有的平行SVR。每个SVR功能相同。CC统计SVR的状态（死活）和负载，以方便调用方使用合适的SVR。

每个SVR最好安装ConfigAgent（CA）来配合CC的工作。

**机器状态**

只有alive的机器/进程可以提供服务。CC需要知道每个SVR是否alive，不能让调用方调用死的SVR。

当CC发现一个SVR可能dead的时候，安全些的做法是ping下，确认ping不通才记录SVR为dead，以防止是CA失效造成的假象。其实，一般的系统都会给为CA做进程监控，死掉的CA会被自动拉起，当然CA从死到监控进程发现也是有时间间隔的（<监控进程探测的间隔时间），CC用ping确认还是安全些。
<!-- more -->
**机器负载**

系统中不同的SVR的处理能力不同，所以，每个SVR的实时负载一般也不相同。CC需要知道每个SVR的负载，方便调用方选择负载最轻的SVR。

机器负载可以大致分为：

（1）静态负载——机器本身的处理能力，主要又硬件决定，CPU、内存、网卡等。如：8核 > 4核。

（2）动态负载——机器某一时刻的负载。即便是硬件相同的机器，提供相同的服务，接收请求多的机器的负载和请求少的机器的负载也不会相同。动态负载最能反映一台机器的当前处理能力了。

死的SVR的负载可以认为是0。不过一般会给死的SVR的负载记为一个极小的数值，以免所有CC出现问题或其他问题导致整个系统不能正常工作（如果CC认为所有SVR负载为0，就不给任何SVR发任务了；如果CC认为所有SVR负载为0.01，则退化为平均分发任务给SVR）。

**任务分配方式**

（1）如果每个SVR都可以处理N种请求，每种请求的处理时间相差较大。CC最好知道每个SVR的动态负载，将新的请求分配给目前负载最轻的SVR。

（2）如果每个SVR只处理1种请求，或者处理N种处理时间差不多的请求。CC可以只知道机器的初始负载（静态负载），CC按SVR能力分配请求，硬件好的得到的请求多，硬件差的得到的请求少，保证系统一直以负载均衡的方式运行。

**机器状态的获取**

（1）耦合大的集群（通常是一个系统），最好每个SVR安装一个ConfigAgent（CA）用来和CC通信。

这样，CA可以定期上报自己的状态给CC，CC定期扫描上报结果，更新SVR的负载/死活（更新慢些，但是CC负载轻）；

或者，CC定期询问CA，主动探测SVR状态（更新及时，但是CC负载重）。

（2）对于系统外的机器，可能不方便也不好强制安装CA。CC只能统计这些机器的收包、回包情况，计算它们的负载。如果是UDP请求，SVR又不回包，那就没办法了。

**负载均衡算法**

这里主要说任务分配方式（2）的负载均衡算法。

转盘法

每个SVR有个权值。选择时，生成一个随机数（大小不超过所有SVR权值之和），从第一个SVR的权值开始累加，累加到生成的随机数的大小，就选择相应的SVR发送请求。以此达到负载均衡——权重高的SVR收到请求的概率就高。

[code lang="cpp"]
value = rand() % sum(svr_list.weight);

temp = 0;
for (i = 0; i < svr_num; i++)
{
    temp += svr_list[i].weight;

    if (temp >= value)
    {
        choose_svr_index = i;
        break;
    }
}
[/code] 
