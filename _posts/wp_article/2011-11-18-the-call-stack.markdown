---
author: illidan
comments: true
date: 2011-11-18 09:25:00+00:00
layout: post
slug: the-call-stack
title: 函数调用的堆栈
wordpress_id: 264
categories:
- 开发运营
---





![1321440763_94.png](http://top.oa.com/pictures/201111/1321440763_94.png)









![1321440772_19.png](http://top.oa.com/pictures/201111/1321440772_19.png)









![1321440780_29.png](http://top.oa.com/pictures/201111/1321440780_29.png)









首先我们来看一下显示调用栈所依据的原理。每个线程都有一个栈结构，用来记录函数的调用过程，这个栈是由高地址向低地址增长的，即栈底的地址比栈顶的地址大。ESP寄存器的值是栈顶的地址，通过增加或减小ESP的值可以缩减或扩大栈的大小。现在我们再来详细地看看这个过程：





①在栈上压入参数。





②执行CALL指令，在栈上压入函数的返回地址。





③压入EBP寄存器的值。（上一层函数的"栈帧"<每个函数在栈上都会保存有一个EBP值，标志了一个函数调用的开始，这就像分界线一样，将每个函数调用区分开来>压栈）





④将ESP寄存器的值赋给EBP寄存器。（本函数的开始地址<ESP是当前栈顶的位置>赋值给EBP，在这个函数结束之前，EBP都存储着这个函数的开始地址）





⑤减小ESP寄存器的值，为局部变量分配空间。





⑥执行函数代码。





⑦将EBP寄存器的值赋给ESP寄存器，等于回收了局部变量的空间。





⑧弹出栈顶的值，赋给EBP，即将第③步中压入的值重新赋给EBP。





⑨执行RET指令，弹出栈顶的返回地址。如果被调用函数负责回收参数的空间，则需要增加ESP的值。









函数调用过程的第③步和第④步使得各个压入的EBP值形成了一个链表的结构，而EBP寄存器是链表的表头，如下图所示：





![1321440793_97.png](http://top.oa.com/pictures/201111/1321440793_97.png)





正是这种链表结构的存在，使得获取函数调用栈成为可能。只要从EBP寄存器开始，沿着链表层层往上，就可以得到函数调用的轨迹。









由于EBP在当前函数调用中的不变性，调试版的程序都使用EBP作为变量和参数的基址，将EBP的值与一个偏移值相加就可以得到变量或参数的地址。有些发行版的程序会对函数的调用过程进行优化，省略了压入EBP的步骤，因此不能再使用EBP作为变量和参数的基址，也不能使用EBP链表来获取函数调用栈。

  


（这篇不是原创，是贴了3篇文章的一部分，自己也写了几句话。一边查找信息一边粘贴，引用的文章已经找不到了——态度很不严谨，以后注意~~）
